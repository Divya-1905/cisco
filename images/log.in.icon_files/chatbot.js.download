/* chatbot.js : UI Controller for Buff Bot (New Window)
 * based on Cisco ChatController.js
 *
 * dependencies:
 *   -- j/userInfoDispatcher.js for cdc.userInfoDispatcher.getUserProfile()
 *   -- buttonmapper.json
 *  version 03-03-2021
 *
 */
 

if (!window.hasOwnProperty("cdc")) { window.cdc = {}; }
/* the following is a chat controller class that when instantiated via 'new' exposes these methods:
 *
 * - init()
 * - getChatInstance()
 *
 */

cdc.nHc = function () {
        "use strict"; // jslint does not allow this in global scope
        var myState = null;
        const urlParams = new URLSearchParams(window.location.search);
        /*
         * Based on LiveAgentAdapter (written by masridha@cisco.com)
         */

        function noHoldAdapter(chatlog, addEvent, getCookie) {
                chatlog("[0.4]          -- begin Adapter constructor...");
                //this is the stage url


                var environmental = cdc.util.findEnvironment();

                //console.log("Environment = " + environmental);


                if (!environmental || environmental == "unknown") {
                        environmental = "prod";
                }

                var enviro = urlParams.get('enviro');
                let loggedinbtnclass = document.getElementsByClassName('login-url');


                if (environmental == "prod") {
                        if(loggedinbtnclass !== undefined && loggedinbtnclass !== null && loggedinbtnclass.length > 0){
                          var nhurl = "https://spyder.cisco.com/app/v2/chat?id=f5f833f2-2210-47f8-b02e-1b093cb821bc";
                        }else{
                          var nhurl = "https://spyder.cisco.com/app/v1/chat?id=f5f833f2-2210-47f8-b02e-1b093cb821bc"
                        }
                } else {
                      if(loggedinbtnclass!== undefined && loggedinbtnclass !== null && loggedinbtnclass.length > 0){
                        var nhurl = "https://buffweb-prodsb-alln.cisco.com/app/v2/chat?id=f5f833f2-2210-47f8-b02e-1b093cb821bc";
                      }else{
                        var nhurl = "https://buffweb-prodsb-alln.cisco.com/app/v1/chat?id=f5f833f2-2210-47f8-b02e-1b093cb821bc";
                      }
                }

                if (enviro == "prod") {
                  
                   if(loggedinbtnclass !== undefined && loggedinbtnclass !== null && loggedinbtnclass.length > 0){
                        var nhurl = "https://spyder.cisco.com/app/v2/chat?id=f5f833f2-2210-47f8-b02e-1b093cb821bc";
                   }else{
                        var nhurl = "https://spyder.cisco.com/app/v1/chat?id=f5f833f2-2210-47f8-b02e-1b093cb821bc";
                   }
                } else if (enviro == "stage") {
                   if(loggedinbtnclass !== undefined && loggedinbtnclass !== null && loggedinbtnclass.length > 0){
                        var nhurl = "https://buffweb-prodsb-alln.cisco.com/app/v2/chat?id=f5f833f2-2210-47f8-b02e-1b093cb821bc";
                   }else{
                        var nhurl = "https://buffweb-prodsb-alln.cisco.com/app/v1/chat?id=f5f833f2-2210-47f8-b02e-1b093cb821bc";
                   }
                }

                //below is the prod url
                //todo :check if the page has chatbottest.js or chatbot.js and dynamically change prod and stage urls
                //var nhurl = "https://spyder.cisco.com/app/v2/chat?id=f5f833f2-2210-47f8-b02e-1b093cb821bc";
                //var nhurl = "https://buffweb-prodsb-alln.cisco.com/app/v2/chat?id=f5f833f2-2210-47f8-b02e-1b093cb821bc";
                // AS: function to build Parameters
                function addnHparam(name, value) {
                        nhurl = nhurl + "&" + name + "=" + value;
                }

                /*
                 * incoming object param 'p':
                 *
                 * var result = {
                 *    'chatNode'  : chatNode,
                 *    'state'     : state,
                 *    'wireParams': wireParams,
                 *    'myself'    : myself
                 * };
                 *
                 * and 'p.wireParams' is
                 *
                 * wireParams:
                 *       var wireParams = {
                 *          'buttonId'    : resolveId(chatNode, state.buttonInfo.buttonId,'button'),
                 *          'proactiveId' : resolveId(chatNode, state.buttonInfo.proactiveId,'proactive'),
                 *          'keyCode'     : chatNode.getAttribute("data-c2c-keycode"),
                 *       };
                 *
                 */

                // AS: Modified setup function gets params from wire and builds the URL, then writes the button link to the page
                this.setup = function (p) {


                        // define a simple XHR handler to gain independence from jQuery
                        function grabJson(params) {
                                var xhr = false,
                                        resp = '';

                                try { xhr = new XMLHttpRequest(); } // most browsers
                                catch (ignore) {
                                        // must be IE
                                        try { xhr = new ActiveXObject("Msxml2.XMLHTTP"); } // IE
                                        catch (ignore) { // e2
                                                // must be _old_ IE
                                                try { xhr = new ActiveXObject("Microsoft.XMLHTTP"); } // try an older version
                                                catch (ignore) { // e3
                                                        return false;
                                                }
                                        }
                                }
                                if (!xhr) { return false; }

                                if (typeof params.success !== 'function') { params.success = function () { }; }
                                if (typeof params.error !== 'function') { params.error = function () { }; }

                                xhr.onreadystatechange = function () {
                                        if (xhr.readyState === 4) {
                                                if (xhr.status === 200) {
                                                        try { resp = JSON.parse(xhr.responseText); }
                                                        catch (syntaxError) {
                                                                return params.error(xhr, 'parsererror', syntaxError.message);
                                                        }
                                                        return params.success(resp, xhr.statusText, xhr);
                                                }
                                                else {
                                                        return params.error(xhr, xhr.statusText, 'error');
                                                }
                                        }
                                };

                                xhr.open("GET", params.url, true);
                                //xhr.open('GET', params.url + '?' + new Date().getTime(), true);

                                if (params.hasOwnProperty('contentType')) {
                                        xhr.setRequestHeader('Content-Type', 'application/json');
                                }

                                if (params.hasOwnProperty('authority')) {
                                        xhr.setRequestHeader("Authority", params.authValue);
                                }

                                if (params.hasOwnProperty('withCredentials')) {
                                        xhr.withCredentials = true;
                                }

                                if (params.headers) {
                                        // jslint made me do this instead of 'for in'... *sigh*
                                        Object.keys(params.headers).forEach(
                                                function (key) {
                                                        xhr.setRequestHeader(key, params.headers[key]);
                                                }
                                        );
                                }

                                xhr.send(null);
                                return xhr;
                        } // end getJson()       

                        //const urlParams = new URLSearchParams(window.location.search);
                        var cocoaPopupOverride = urlParams.get('c2cPopupOverride2');
                        var showProactiveConsole = urlParams.get('showProactiveConsole2');

                        function chatLogProactive(msg) {
                                if (showProactiveConsole == 1) {
                                        console.log(JSON.stringify(msg));
                                }
                        }
                        function GetPropertyValue(obj1, dataToRetrieve) {
                                return dataToRetrieve
                                        .split('.') // split string based on `.`
                                        .reduce(function (o, k) {
                                                return o && o[k]; // get inner property if `o` is defined else get `o` and return
                                        }, obj1) // set initial value as object
                        }

                        //Check the buff api as to whether the chatbot is working or not before displaying the 'Chat Now' button
                        //and proactive chat 
                        var isBuffWorking, isBuffWorkingStatus;
                        function isBuffWorking() {
                                //  return new Promise(function(resolve, reject) {

                                var buffURL = "https://spyder.cisco.com/buff/v1.0/eman";
                                //var buffURL = "https://buffweb-prodsb-alln.cisco.com/buff/v1.0/eman";
                                grabJson({
                                        url: buffURL,
                                        withCredentials: true,
                                        success: function (res) {
                                                //chatLogProactive("1.5 -[proactive-cocoa] -- User threshold data from callback = "+ res);
                                                //console.log(JSON.stringify(res));
                                                chatLogProactive("[5.2] -[proactive-cocoa] -- " + buffURL);
                                                chatLogProactive("[5.2] -[proactive-cocoa] -- Response from BUFF status v1.0/eman endpoint : " + JSON.stringify(res));
                                                //console.log("-------res.hasOwnProperty-------->" + res.hasOwnProperty("status"));
                                                if (res && res.hasOwnProperty("status")) {

                                                        isBuffWorkingStatus = GetPropertyValue(res, "status");

                                                        if (isBuffWorkingStatus == "success") {
                                                                isBuffWorking = 1;
                                                                chatLogProactive("[5.21] -[proactive-cocoa] -- BUFF status v1.0/eman endpoint : SUCCESS - BUFF IS RUNNING");
                                                                if (document.getElementsByClassName('vabutton').length < 1) {
                                                                        document.getElementById("nhbtn").appendChild(aTag);
                                                                }
                                                        } else {
                                                                isBuffWorking = 0;
                                                                chatLogProactive("[5.21] -[proactive-cocoa] -- BUFF status v1.0/eman endpoint : FAILURE - BUFF IS DOWN");
                                                        }

                                                } else {
                                                        isBuffWorking = 0;
                                                        chatLogProactive("[5.21] -[proactive-cocoa] -- BUFF status v1.0/eman endpoint : FAILURE - BUFF IS DOWN");
                                                }
                                        },
                                        error: function (err) {
                                                isBuffWorking = 0;
                                                chatLogProactive("[5.21] -[proactive-cocoa] -- BUFF status v1.0/eman endpoint : FAILURE - BUFF IS DOWN");
                                        }
                                });
                                // });
                        } // end isBuffWorking()               





                        var wire = p.wireParams,
                                proactiveNodes,
                                i;

                        chatlog("[4.4] -- begin Adapter.setup()");
                        chatlog("[4.4]    -- buttonId=[" + wire.buttonId + "], proactiveId=[" + wire.proactiveId + "], keyCode=[" + wire.keyCode + "]...");
                        chatlog("[4.4]    -- chatNode: ", p.chatNode);

                        var svcConfig = p.state.envConfig,
                                cpGutcVal = getCookie('CP_GUTC'),
                                chatNowButton = p.chatNode;

                        // add the wire button Id to the actual button itself so it can be read on click
                        function stripExtraChars(param){
                            let arr = new Array();
                            arr[0] = param;
        
                            if(param.indexOf('&') > -1) {
                                     arr = param.split('&');  
                            } else if(param.indexOf('?') > -1) {
                                     arr = param.split('?');        
                            } else if(param.indexOf('#') > -1) {
                                     arr = param.split('#');        
                            } 
        
                            return arr[0];
                        }
                        if (!p.state.flags.detailsAdded) {

                                if (wire["data-c2c-ecid"]) {
                                        chatlog("[4.4]    -- adding data-c2c-ecid=[" + wire["data-c2c-ecid"] + "]");
                                        addnHparam('datac2cecid', stripExtraChars(wire["data-c2c-ecid"]));
                                }
                                else {
                                        chatlog("[4.4]    -- data-c2c-ecid is null");
                                }
                                if (wire["data-c2c-oid"]) {
                                        chatlog("[4.4]    -- adding data-c2c-oid=[" + wire["data-c2c-oid"] + "]");
                                        addnHparam('datac2coid', stripExtraChars(wire["data-c2c-oid"]));
                                }
                                else {
                                        chatlog("[4.4]    -- data-c2c-oid is null");
                                }
                                if (wire["data-c2c-ccid"]) {
                                        chatlog("[4.4]    -- adding data-c2c-ccid=[" + wire["data-c2c-ccid"] + "]");
                                        addnHparam('datac2cccid', stripExtraChars(wire["data-c2c-ccid"]));
                                }
                                else {
                                        chatlog("[4.4]    -- data-c2c-ccid is null");
                                }
                                if (wire["data-c2c-dtid"]) {
                                        chatlog("[4.4]    -- adding data-c2c-dtid=[" + wire["data-c2c-dtid"] + "]");
                                        addnHparam('datac2cdtid', stripExtraChars(wire["data-c2c-dtid"]));
                                }
                                else {
                                        chatlog("[4.4]    -- data-c2c-dtid is null");
                                }

                                		
                                if (wire["data-c2c-eid"]) {	
                                        chatlog("[4.4]    -- adding data-c2c-eid=[" + wire["data-c2c-eid"] + "]");	
                                        addnHparam('datac2ceid', stripExtraChars(wire["data-c2c-eid"]));	
                                }	
                                else {	
                                        chatlog("[4.4]    -- datac2ceid is null");	
                                }
                                if (wire["buttonId"]) {
                                        // chatlog("[4.4]    -- adding buttonId=[" + wire["buttonId"] + "]");
                                        // hard coding buttonid for popup chat window (phase 1)
                                        addnHparam('buttonId', '57334000000GnRJ')
                                        var nhButtonID = '57334000000GnRJ'
                                        // addnHparam('buttonId', wire["buttonId"]);
                                        // var nhButtonID = wire["buttonId"];
                                }
                                else {
                                        addnHparam('buttonId', '57334000000GnRJ');
                                        chatlog("[4.4]    -- buttonId is null");
                                        var nhButtonID = '57334000000GnRJ';
                                }

                                chatlog("[4.4]    -- adding detail for CP_GUTC cookie=[" + cpGutcVal + "]");
                                addnHparam('CookieInput', cpGutcVal || '');

                                chatlog("[4.4]    -- adding detail for doc URL=[" + document.URL + "]");
                                addnHparam('OriginatingURL', encodeURIComponent(document.URL));

                                chatlog("[4.4]    -- adding detail for referring URL=[" + document.referrer + "]");
                                addnHparam('ReferringURL', encodeURIComponent(document.referrer));

                                if (p.state.locale.country.visitor) {
                                        chatlog("[4.4]    -- adding detail for visitor country=[" + p.state.locale.country.visitor + "]");
                                        addnHparam('CountryInput', p.state.locale.country.visitor || '');
                                }
                                else {
                                        chatlog("[4.4]    -- adding detail for visitor country=[" + p.state.locale.country.page + "]");
                                        addnHparam('CountryInput', p.state.locale.country.page || '');
                                }
                                
                                
                                if (p.state.locale.page) {
                                        chatlog("[4.4]    -- adding detail for visitor language=[" + p.state.locale.chosen + "]");
                                        addnHparam('LanguageInput', p.state.locale.chosen || '');
                                        //chatlog("[4.4]    -- adding detail for visitor language=[" + p.state.locale.page + "]")
                                }
                                
                                
                                
                                

                                chatlog("[4.4]    -- adding detail for depId=[" + svcConfig.deployment_id + "]; orgId=[" + svcConfig.org_id + "]");
                                addnHparam('deploymentId', svcConfig.deployment_id);
                                addnHparam('orgId', svcConfig.org_id);

                                p.state.flags.detailsAdded = true;
                                nhurl = nhurl.replace("datac2coid", "eloquaOfferId");
                                nhurl = nhurl.replace("datac2cccid", "eloquaCcid");
                                nhurl = nhurl.replace("datac2ceid", "eloquaEid");	
                                nhurl = nhurl.replace("datac2cdtid", "eloquaDriveToId");
                                nhurl = nhurl.replace("oid", "eloquaOfferId");
                                nhurl = nhurl.replace("ccid", "eloquaCcid");
                                nhurl = nhurl.replace("dtid", "eloquaDriveToId");
                                nhurl = nhurl.replace("eid", "eloquaEid");
                                cdc.nHc.nhurl = nhurl;
                                let nhurl_reactive = nhurl + "&isProactive=0";
                                var aTag = document.createElement("a");
                                aTag.setAttribute("class", "vabutton");
                                aTag.setAttribute("href", "javascript:void(0);");
                                aTag.setAttribute("onclick", "trackEvent.event('link', {'lpos': 'Cisco Reactive Chat Fire','lid': 'Reactive chat'}); window.open('" + nhurl_reactive + "','cocoa','height=600,width=514');window.reactiveCocoaOn=1; sessionStorage['proactiveCocoaSession'] = JSON.stringify({'state':'off'});if (null !== document.getElementById('cocoa-proactice-chat')) document.getElementById('cocoa-proactice-chat').style.display = 'none';");


                                if (!null === cocoaBotTranslateObject) {
                                        chatlog("PROACTIVE CHAT LOCALIZATION: Reading localization data from cocoaBotTranslateObject.");
                                        //console that its coming from the dictionary object
                                } else {
                                        chatlog("PROACTIVE CHAT LOCALIZATION: NOT Reading localization data from cocoaBotTranslateObject. Falling back on hardcoded English.");
                                        //fallback on hardcoded english translation. also make sure to console that its falling back

                                        //var cocoaBotTranslateObject={"Cisco_Proactive_Chat_Intro":"Welcome to Cisco!","Cisco_Chat_Now":"Chat with Sales","Cisco_Proactive_Chat_Content":"How can I help you?","Cisco_Proactive_Chat_Decline_Title":"Decline the chat invitation","Cisco_Proactive_Chat_Metrics_Group":"pop up chat","Cisco_Proactive_Chat_Decline":"No Thanks","Cisco_Proactive_Chat_Intro_Title":"Cisco:","Cisco_Proactive_Chat_Accept_Metrics_Item":"accept the chat invitation","Cisco_Proactive_Chat_Decline_Metrics_Item":"decline the chat invitation","Cisco_Proactive_Chat_Title":"Chat live with a Cisco representative","Cisco_Proactive_Chat_Accept_Title":"Accept the chat invitation","Cisco_Proactive_Chat_Accept":"Chat Now"};
                                        chatlog(cocoaBotTranslateObject["Cisco_Chat_Now"]);
                                }


                                aTag.innerHTML = cocoaBotTranslateObject["Cisco_Chat_Now"];
                                //document.getElementById("nhbtn").appendChild(aTag);
                                isBuffWorking();

                                // create proactive chat here

                                // check if var proactiveCocoaOff = true (it means you dont use proactive chat on this page)
                                // check query string for parameter proactiveCocoaTimer=X , and change the timer from 60 seconds to X
                                // check if session storage exists 'cocoabot' (it means that user already said no to chat during this session)
                                // check if 60 seconds passed (only turn on chat after 60 seconds)
                                // check if reactive Cocoa Bot was used (onclick function on reactive button that sets var reactiveCocoaOn=true)
                                // check that NBA is not 0

                                // if the above checks are passed then show the proactive chat

                                //not all pages have the css file needed to show the proactive chat. TODO: in future the little css that's needed should be bundled with this file								
                                document.getElementsByTagName("head")[0].insertAdjacentHTML(
                                        "beforeend",
                                        "<link rel=\"stylesheet\" href=\"https://www.cisco.com/etc/designs/cdc/dm/chat/clientLib.min.css\" />");

                                function proactiveChatTimer(time, update, complete) {
                                        //we need to have an accurate count of 60 seconds before proactive bot shows up
                                        var start = new Date().getTime();
                                        var interval = setInterval(function () {
                                                var now = time - (new Date().getTime() - start);
                                                if (now <= 0) {
                                                        clearInterval(interval);
                                                        complete();
                                                }
                                                else update(Math.floor(now / 1000));
                                        }, 100); // the smaller this number, the more accurate the timer will be
                                }


                                if (null === showProactiveConsole) {
                                        // there is no override
                                        showProactiveConsole = 0;
                                } else {
                                        showProactiveConsole = 1;
                                }
                                //logs the chat based on query string
                                function chatLogProactive(msg) {
                                        if (showProactiveConsole == 1) {
                                                console.log(JSON.stringify(msg));
                                        }
                                }


                                // define a simple XHR handler to gain independence from jQuery
                                function grabJson(params) {
                                        var xhr = false,
                                                resp = '';

                                        try { xhr = new XMLHttpRequest(); } // most browsers
                                        catch (ignore) {
                                                // must be IE
                                                try { xhr = new ActiveXObject("Msxml2.XMLHTTP"); } // IE
                                                catch (ignore) { // e2
                                                        // must be _old_ IE
                                                        try { xhr = new ActiveXObject("Microsoft.XMLHTTP"); } // try an older version
                                                        catch (ignore) { // e3
                                                                return false;
                                                        }
                                                }
                                        }
                                        if (!xhr) { return false; }

                                        if (typeof params.success !== 'function') { params.success = function () { }; }
                                        if (typeof params.error !== 'function') { params.error = function () { }; }

                                        xhr.onreadystatechange = function () {
                                                if (xhr.readyState === 4) {
                                                        if (xhr.status === 200) {
                                                                try { resp = JSON.parse(xhr.responseText); }
                                                                catch (syntaxError) {
                                                                        return params.error(xhr, 'parsererror', syntaxError.message);
                                                                }
                                                                return params.success(resp, xhr.statusText, xhr);
                                                        }
                                                        else {
                                                                return params.error(xhr, xhr.statusText, 'error');
                                                        }
                                                }
                                        };

                                        xhr.open("GET", params.url, true);
                                        //xhr.open('GET', params.url + '?' + new Date().getTime(), true);

                                        if (params.hasOwnProperty('contentType')) {
                                                xhr.setRequestHeader('Content-Type', 'application/json');
                                        }

                                        if (params.hasOwnProperty('authority')) {
                                                xhr.setRequestHeader("Authority", params.authValue);
                                        }

                                        if (params.hasOwnProperty('withCredentials')) {
                                                xhr.withCredentials = true;
                                        }

                                        if (params.headers) {
                                                // jslint made me do this instead of 'for in'... *sigh*
                                                Object.keys(params.headers).forEach(
                                                        function (key) {
                                                                xhr.setRequestHeader(key, params.headers[key]);
                                                        }
                                                );
                                        }

                                        xhr.send(null);
                                        return xhr;
                                } // end getJson()

                                var proactiveNBA;

                                function GetPropertyValue(obj1, dataToRetrieve) {
                                        return dataToRetrieve
                                                .split('.') // split string based on `.`
                                                .reduce(function (o, k) {
                                                        return o && o[k]; // get inner property if `o` is defined else get `o` and return
                                                }, obj1) // set initial value as object
                                }

                                function addMetrics(res) {
                                        if(res && res.data && 
                                            res.data.cookie_id &&
                                            res.data.p1 && res.data.threshold
                                            && res.data.model_id
                                            && res.data.prediction_table_id){
                                            chatlog('[4.1] -- Adding Metrics for proactive modal agree.');
                                            cdc.util.addMetricsRule('.c2c-proactive-agree', {
                                                                           'lpos':'pop up chat',
                                                                           'cookie_id':res.data.cookie_id,
                                                                           'p1':res.data.p1,
                                                                           'threshold':res.data.threshold,
                                                                           'model_id':res.data.model_id,
                                                                           'prediction_table_id':res.data.prediction_table_id,
                                                                           'action':'accepted'
                                                                         });
                                             chatlog('[4.1] -- Adding Metrics for proactive modal dismiss.');
                                             cdc.util.addMetricsRule('.c2c-proactive-dismiss', {
                                                                           'cookie_id':res.data.cookie_id,
                                                                           'p1':res.data.p1,
                                                                           'threshold':res.data.threshold,
                                                                           'model_id':res.data.model_id,
                                                                           'prediction_table_id':res.data.prediction_table_id,
                                                                           'action':'rejected'
                                                                         });
                                        }
                                }

                                function prepareProactiveModal() {
                                        return new Promise(function (resolve, reject) {
                                                var environment = cdc.util.findEnvironment();

                                                //var environment = "prod";


                                                if (!environment || environment == "unknown") {
                                                        environment = "prod";
                                                }

                                                var nbaURL = "https://nbbadataservice-" + environment + ".cisco.com/getuserdataV1";

                                                chatLogProactive("[1.5] -[proactive-cocoa] -- Begin to fetch user threshold data using url... " + nbaURL);
                                                grabJson({
                                                        url: nbaURL,
                                                        withCredentials: true,
                                                        success: function (res) {
                                                                //chatLogProactive("1.5 -[proactive-cocoa] -- User threshold data from callback = ", res);
                                                                // chatLogProactive ("-------tempProactiveNBA-------->", tempProactiveNBA);
                                                                // chatLogProactive ("-------res-------->", res);
                                                                // chatLogProactive ("-------res.data-------->", res.data);
                                                                // chatLogProactive ("-------res.data.hasOwnProperty-------->" + res.data.hasOwnProperty("c2c_popup_flag"));
                                                                if (res && res.data && res.data.hasOwnProperty("c2c_popup_flag")) {
                                                                        var tempProactiveNBA = GetPropertyValue(res.data, "c2c_popup_flag");
                                                                        if (tempProactiveNBA == "1") {
                                                                                chatLogProactive("[1.5] -[proactive-cocoa] -- NBA is 1 from API.");
                                                                                proactiveNBA = 1;
                                                                                chatLogProactive(res);
                                                                                addMetrics(res);

                                                                        } else if (tempProactiveNBA == "0") {
                                                                                chatLogProactive("[1.5] -[proactive-cocoa] -- NBA is 0 from API.");
                                                                                proactiveNBA = 0;
                                                                                addMetrics(res);
                                                                        } else {
                                                                                chatLogProactive("[1.5] -[proactive-cocoa] -- NBA is not 1 or 0 from API so setting to 1.");
                                                                                proactiveNBA = 1;
                                                                                addMetrics(res);
                                                                        }

                                                                } else {
                                                                        chatLogProactive("[1.5.1] -- NBA is returning a 404 message. Are you in Incognito Browser Mode? NBA will be set to 1.");
                                                                        proactiveNBA = 1;
                                                                        addMetrics(res);
                                                                }
                                                        },
                                                        error: function (err) {
                                                                chatLogProactive("[1.5] -[proactive-cocoa] -- Error fectching NBA data = " + err);
                                                        }
                                                });

                                        });
                                } // end prepareProactiveModal()




                                //alert(cocoaPopupOverride);

                                if (null === cocoaPopupOverride) {
                                        // there is unknown override
                                        cocoaPopupOverride = 0;
                                } else {
                                        // there is an override
                                        if (cocoaPopupOverride === "1") {
                                                // show the override
                                                //alert("2");
                                                cocoaPopupOverride = 1;
                                        } else {
                                                // there is no override
                                                cocoaPopupOverride = 0;
                                        }
                                }



                                if ('undefined' !== typeof proactiveCocoaOff) {


                                        chatLogProactive("[1.0] -[proactive-cocoa] -- proactiveCocoaOff is true. Don't show Proactive Cocoa Chat.");
                                } else {

                                        chatLogProactive("[1.0] -[proactive-cocoa] -- proactiveCocoaOff is false. Show Proactive Cocoa Chat.");
                                        prepareProactiveModal();

                                        var proactiveCocoaTimer = urlParams.get('proactiveCocoaTimer');
                                        if (null === proactiveCocoaTimer) {
                                                if(window.location.href.includes("/c/en/us/solutions/hybrid-work.html") || window.location.href.includes("/content/en/us/solutions/hybrid-work.html") ){
                                                    proactiveCocoaTimer = 45000;  
                                                }else{
                                                    proactiveCocoaTimer = 60000;
                                                }
                                                chatLogProactive("[1.1] -[proactive-cocoa] -- proactiveCocoaTimer remains at 60 seconds");
                                        } else {
                                                //proactiveCocoaTimer = 12000;
                                                chatLogProactive("[1.1] -[proactive-cocoa] -- proactiveCocoaTimer changed to " + proactiveCocoaTimer + " seconds");
                                                proactiveCocoaTimer *= 1000;
                                        }


                                        //const proactiveCocoaState = {'state':'off'};
                                        //sessionStorage['proactiveCocoaSession'] = JSON.stringify(proactiveCocoaState);
                                        if ('undefined' !== typeof sessionStorage['proactiveCocoaSession']) {
                                                //
                                                chatLogProactive("[1.2] -[proactive-cocoa] -- Had Chatbot Session. Do not show Proactive Chatbot");
                                        } else {
                                                chatLogProactive("[1.2] -[proactive-cocoa] -- First Chatbot Session. Show Proactive Chatbot");
                                                proactiveChatTimer(
                                                        proactiveCocoaTimer, // milliseconds
                                                        function (timeleft) { // called every step to update the visible countdown
                                                                // document.getElementById('timer').innerHTML = timeleft+" second(s)";
                                                                chatLogProactive(timeleft); //TODO: Rewrite to have this shown in console onnly if debug query string variable is 1

                                                        },
                                                        function () { // what to do after
                                                                chatLogProactive("[1.3] -[proactive-cocoa] -- Timer finished");
                                                                if ('undefined' !== typeof reactiveCocoaOn) {
                                                                        chatLogProactive("[1.4] -[proactive-cocoa] -- Reactive Chatbot Used. Don't show Proactive Chat");
                                                                } else {
                                                                        chatLogProactive("[1.4] -[proactive-cocoa] -- Reactive Chat not Used. Show Proactive Chatbot");
                                                                        //chatLogProactive("NBA Value = " + proactiveNBA);
                                                                        if (proactiveNBA === 1) {
                                                                                chatLogProactive("[1.5] -[proactive-cocoa] -- NBA = 1. Show Proactive Chatbot");
                                                                                if ((isBuffWorking == 1) && (typeof cocoaAB != "function")) {
                                                                                        chatLogProactive("[1.6] -[proactive-cocoa] -- Buff Service is Working. Show Proactive Cocoa Chat.");
                                                                                        chatLogProactive("[1.6.1] -[proactive-cocoa] -- NO A/B test Available. Show standard proactive chat.");






                                                                                        var a = 1, b = 2;
                                                                                        var div = document.createElement('div');
                                                                                        div.setAttribute('class', 'dmc-proactivechat dm0 c2c-proactive-modal');
                                                                                        div.setAttribute('id', 'cocoa-proactice-chat');
                                                                                        div.setAttribute('style', 'position: fixed; top: 72%; left: 50%; transform: translate(-50%, -50%); z-index: 10000; animation-name: slide573340000004DIt; animation-duration: 1s; animation-iteration-count: 2; animation-direction: alternate; animation-timing-function: ease-in-out; animation-play-state: paused;');
                                                                                        div.setAttribute('data-config-metrics-item', 'prediction_table_id');
                                                                                        div.setAttribute('data-config-metrics-group', 'prediction_table_id');
                                                                                        let nhurl_proactive = nhurl + "&isProactive=1";

                                                                                        div.innerHTML = `
                              <div class="proac-head">
                                <div class="cisco-logo"></div>
                                <div class="proac-content">
                                      <p>${cocoaBotTranslateObject["Cisco_Proactive_Chat_Title"]}</p>
                                </div>
                                <div class="cisco-icon">
                                        <a class="c2c-proactive-dismiss" href="javascript:void(0)" onclick = "sessionStorage['proactiveCocoaSession'] = JSON.stringify({'state':'off'});document.getElementById('cocoa-proactice-chat').style.display = 'none';" alt="${cocoaBotTranslateObject["Cisco_Proactive_Chat_Decline_Title"]}" title="${cocoaBotTranslateObject["Cisco_Proactive_Chat_Decline_Title"]}" data-config-metrics-item="${cocoaBotTranslateObject["Cisco_Proactive_Chat_Decline_Metrics_Item"]}" data-config-metrics-group="${cocoaBotTranslateObject["Cisco_Proactive_Chat_Metrics_Group"]}"></a>
                                </div>
                                </div>
                              <div class="proac-container">
                                    <p class="content">${cocoaBotTranslateObject["Cisco_Proactive_Chat_Intro_Title"]}</p>
                                <ul>
                                      <li>${cocoaBotTranslateObject["Cisco_Proactive_Chat_Intro"]}</li>
                                      <li>${cocoaBotTranslateObject["Cisco_Proactive_Chat_Content"]}</li>
                                </ul>
                              </div>
                              
                              <ul class="cta">
                                  <li><a href="javascript:void(0);" onclick = "sessionStorage['proactiveCocoaSession'] = JSON.stringify({'state':'off'});document.getElementById('cocoa-proactice-chat').style.display = 'none';" alt="${cocoaBotTranslateObject["Cisco_Proactive_Chat_Decline_Title"]}" title="${cocoaBotTranslateObject["Cisco_Proactive_Chat_Decline_Title"]}" data-config-metrics-item="${cocoaBotTranslateObject["Cisco_Proactive_Chat_Decline_Metrics_Item"]}" data-config-metrics-group="${cocoaBotTranslateObject["Cisco_Proactive_Chat_Metrics_Group"]}" class="dmc-button atlantic pal-6 c2c-proactive-dismiss">${cocoaBotTranslateObject["Cisco_Proactive_Chat_Decline"]}</a></li>
                                  <li><a href="javascript:void(0);" onclick = "trackEvent.event('link', {'lpos': 'Cisco Proactive Chat Fire','lid': 'pop-up chat'}); window.open('${nhurl_proactive}','cocoa','height=600,width=514');sessionStorage['proactiveCocoaSession'] = JSON.stringify({'state':'off'});document.getElementById('cocoa-proactice-chat').style.display = 'none';" alt="${cocoaBotTranslateObject["Cisco_Proactive_Chat_Accept_Title"]}" title="${cocoaBotTranslateObject["Cisco_Proactive_Chat_Accept_Title"]}" data-config-metrics-item="${cocoaBotTranslateObject["Cisco_Proactive_Chat_Accept_Metrics_Item"]}" data-config-metrics-group="${cocoaBotTranslateObject["Cisco_Proactive_Chat_Metrics_Group"]}" class="dmc-button atlantic pal-4 c2c-proactive-agree">${cocoaBotTranslateObject["Cisco_Proactive_Chat_Accept"]}</a></li>
                              </ul>
                          `;




                                                                                        document.getElementsByTagName('body')[0].appendChild(div);
                                                                                
                                                                                } else if((isBuffWorking == 1) && (typeof cocoaAB === "function")) {
                                                                                
                                                                                  cocoaAB(cocoaBotTranslateObject, cdc.nHc.nhurl);
                                                                                  chatLogProactive("[1.6] -[proactive-cocoa] -- Buff Service is Working. Show Proactive Cocoa Chat.");
                                                                                  chatLogProactive("[1.6.1] -[proactive-cocoa] -- A/B test Available. Show standard proactive chat.");
                                                                                
                                                                                } else {
                                                                                        chatLogProactive("[1.6] -[proactive-cocoa] -- Buff Service is NOT Working. DO NOT Show Proactive Cocoa Chat.");
                                                                                }
                                                                        } else {
                                                                                chatLogProactive("[1.5] -[proactive-cocoa] -- NBA = 0 or c2cPopupOverride=1. Don't show Proactive Chatbot");
                                                                        }
                                                                }

                                                        }
                                                );
                                        }

                                }

                                //end proactive chat							

                        }
                        else {
                                chatlog("[4.4]    -- chat.init() has run once already, not adding custom details");
                        }
                        chatlog("[4.4] -- end Adapter.setup()");
                }; // end this.setup()
                chatlog("[0.4]          -- end Adapter constructor");
        } // end Adapter()

        // AS: Left myState pretty much as is, TO DO: Decide with Duy what to remove
        function getnHState() {
                if (!myState) {
                        myState = {
                                "version": "1.2",
                                "buttonMapUrl": "//www.cisco.com/c/dam/global/en_us/framework/buttonMapper.json",
                                "chatNodes": null,
                                "debug": "",
                                "entitlement": "",
                                "environment": "",
                                "envConfig": null,
                                "initCounter": 0,
                                "initQ": [],
                                "flags": {
                                        "verbose": false,
                                        "exit": false,
                                        "test": false,
                                        "gotParams": false,
                                        "localeDetermined": false,
                                        "mapperJsonLoaded": false,
                                        "proactiveModalWired": false,
                                        "detailsAdded": false,
                                        "clearCache": false,
                                        "initRunning": false
                                },
                                "locale": {
                                        "page": "",
                                        "visitor": "",
                                        "chosen": "",
                                        "country": {}, // "page" and "visitor"
                                        "lang": {}  // "page" and "visitor"
                                },
                                "override": {
                                        "buttonId": "",
                                        "proactiveId": "",
                                        "entitlement": "",
                                        "locale": ""
                                },
                                "timestamp": {
                                        "all": {},
                                        "json": {},
                                        "deployment": {}
                                },
                                "events": []
                        };
                }
                return myState;
        } // end of getnHState()

        /* nHChat() is an inner class, instantiated via 'new'
         * - its 'init' method is exposed by the outer chat controller instance via 'init()'
         * - the instance itself is exposed via the outer chat controller instance via 'getChatInstance()'
         */

        function nHChat(selector) {
                var state = getnHState(),
                        activeParams = { // handlers for the querystring params we want to react to
                                'cocoaDebug':
                                        function (input) {
                                                state.debug = input;
                                                state.flags.verbose = true; // turn on verbosity if in debug mode
                                        },

                                'cocoaverbose': // can turn off debug verbosity
                                        function (input) { if (input) { state.flags.verbose = true; } else { state.flags.verbose = false; } },

                                'cocoatest':  // AS: pass kptester=1?
                                        function (input) { if (input) { state.flags.test = true; } else { state.flags.test = false; } },

                                'cocoaclearCache':  // AS QUESTION:  purpose of this?  do we need it?
                                        function (input) { if (input) { state.flags.clearCache = true; } else { state.flags.clearCache = false; } },

                                'cocoabuttonOverride':  // AS: may be useful for testing or demos?
                                        function (input) { state.override.buttonId = input; },

                                'cocoalocaleOverride': // AS: may be useful for testing or demos?
                                        function (input) { state.override.locale = input; },

                                'cocoaentitlementOverride': // AS: may be useful for testing or demos in future?
                                        function (input) { state.override.entitlement = input; }

                        }; // end 'activeParams' object

                /*
                 *        PRIVATE METHODS
                 *
                 */
                // AS: used everywhere for logging; left as-is
                function chatlog(msg, msg2) {
                        if (state.flags.verbose) {
                                if (typeof msg === "object") {
                                        if (JSON) {
                                                console.dir(JSON.parse(JSON.stringify(msg)));
                                        }
                                        else {
                                                console.dir(msg);
                                        }
                                }
                                else {
                                        if (!msg2) { msg2 = ""; }
                                        console.log('[' + state.initCounter + '] ' + msg, msg2);
                                }
                        }
                }

                // AS: called by parsenHParams
                function logInit() {
                        chatlog("=============");
                        chatlog("chatController version " + state.version + ": initializing...");
                        chatlog("=============");
                        chatlog("log message prefixes:");
                        chatlog("  0.x -- init()/prepChain()");
                        chatlog("  1.x -- determineLocale()");  // AS: Need this
                        chatlog("  1.x -- do not currently need determineAccessLevel() but may in the future");  // AS: Don't need this
                        chatlog("  2.x -- loadButtonMap()");  // AS: Need this
                        chatlog("  4.x -- wireButtons()");
                        chatlog("  5.x -- checkQueue()");
                        chatlog("-------------");
                }  // end logInit()

                // AS: Used to load ButtonMapper file -- replacement for jquery JSON -- to support Cisco pages that do not use jquery
                function getJson(params) {
                        var xhr = false,
                                resp = '';

                        try { xhr = new XMLHttpRequest(); } // most browsers
                        catch (ignore) {
                                // must be IE
                                try { xhr = new ActiveXObject("Msxml2.XMLHTTP"); } // IE
                                catch (ignore) { // e2
                                        // must be _old_ IE
                                        try { xhr = new ActiveXObject("Microsoft.XMLHTTP"); } // try an older version
                                        catch (ignore) { // e3
                                                return false;
                                        }
                                }
                        }
                        if (!xhr) { return false; }

                        if (typeof params.success !== 'function') { params.success = function () { }; }
                        if (typeof params.error !== 'function') { params.error = function () { }; }

                        xhr.onreadystatechange = function () {
                                if (xhr.readyState === 4) {
                                        if (xhr.status === 200) {
                                                try { resp = JSON.parse(xhr.responseText); }
                                                catch (syntaxError) {
                                                        return params.error(xhr, 'parsererror', syntaxError.message);
                                                }
                                                return params.success(resp, xhr.statusText, xhr);
                                        }
                                        else {
                                                return params.error(xhr, xhr.statusText, 'error');
                                        }
                                }
                        };

                        xhr.open("GET", params.url, true);
                        //xhr.open('GET', params.url + '?' + new Date().getTime(), true);

                        if (params.hasOwnProperty('contentType')) {
                                xhr.setRequestHeader('Content-Type', 'application/json');
                        }

                        if (params.hasOwnProperty('authority')) {
                                xhr.setRequestHeader("Authority", params.authValue);
                        }

                        if (params.hasOwnProperty('withCredentials')) {
                                xhr.withCredentials = true;
                        }

                        if (params.headers) {
                                // jslint made me do this instead of 'for in'... *sigh*
                                Object.keys(params.headers).forEach(
                                        function (key) {
                                                xhr.setRequestHeader(key, params.headers[key]);
                                        }
                                );
                        }

                        xhr.send(null);
                        return xhr;
                } // end getJson()

                // jQuery off() replacement...
                function removeEvent(node, type, handler) {
                        if (!node) { return; }
                        if (!type && node.length) {
                                handler = node[2];
                                type = node[1];
                                node = node[0];
                        }

                        if (node.detachEvent) {
                                node.detachEvent('on' + type, handler);
                        }
                        else {
                                node.removeEventListener(type, handler);
                        }
                }

                // jQuery on() replacement...  (e.g. onclick)
                function addEvent(node, type, handler, state) {
                        if (!type && node.length) {
                                state = node[3];
                                handler = node[2];
                                type = node[1];
                                node = node[0];
                        }
                        chatlog("begin addEvent() -- checking on attachEvent for node " + node);
                        if (typeof node.attachEvent !== 'undefined') {
                                chatlog("-- attachEvent exists, calling it");
                                node.attachEvent('on' + type, handler);
                        }
                        else {
                                chatlog("-- no attachEvent, using addEventListener instead");
                                node.addEventListener(type, handler);
                        }

                        if (state) {
                                state.events.push([node, type, handler]);
                        }
                }

                // AS: KEEP setCookie
                function setCookie(args) {
                        // LEGACY - support old signature (string, string[, int])
                        if (!args.cookieName) {
                                args = { cookieName: args, cookieValue: arguments[1] };
                                if (arguments.length > 2) { args.days = arguments[2]; }
                        }

                        var expireStr = '';
                        var pathStr = '';
                        var domainStr = '';
                        var msecs = parseInt(args.msecs);
                        if (isNaN(msecs) && args.days) {
                                msecs = args.days * 24 * 60 * 60 * 1000;
                        }

                        if (!isNaN(msecs)) {
                                var ex = new Date();
                                ex.setTime(ex.getTime() + msecs);
                                expireStr = "; expires=" + ex.toUTCString();
                        }
                        if (args.path) {
                                pathStr = "; path=" + args.path + ";";
                        } else {
                                pathStr = "; path=/;";
                        }
                        if (args.domain) { domainStr = "; domain=" + args.domain; }
                        try {
                                document.cookie = args.cookieName
                                        + "="
                                        + escape(args.cookieValue)
                                        + expireStr
                                        + pathStr
                                        + domainStr;
                        } catch (e) {
                                return false;
                        }
                        return true;
                }

                // AS: KEEP getCookie
                function getCookie(args) {
                        // LEGACY - if args is a string and not an object
                        if (!args.cookieName) { args = { cookieName: args }; }

                        var frags = document.cookie.split(/\s*;\s*/),
                                dict = {},
                                frag,
                                ioe,
                                name,
                                val,
                                i;

                        for (i = 0; i < frags.length && (frag = frags[i]); i++) {
                                ioe = frag.indexOf('='); // expecting "foo=bar"
                                if (ioe < 0) { continue; }
                                name = unescape(frag.substring(0, ioe));
                                val = unescape(frag.substring(ioe + 1));
                                dict[name] = val;
                        }

                        return dict[args.cookieName] || "";
                }

                // AS: KEEP getParameter
                function getParameter(param, url) {
                        param = param + "=";
                        var qs;
                        if (url) {
                                qs = url.slice(url.indexOf('?') + 1);
                        }
                        qs = qs || window.location.search;
                        var val = "";
                        var start = qs.indexOf(param);
                        if (start != -1) {
                                start += param.length;
                                var end = qs.indexOf("&", start);
                                if (end == -1) {
                                        end = qs.length;
                                }
                                val = qs.substring(start, end);
                        }
                        return val;
                }

                // AS: KEEP parsenHParams
                // grab any meaningful querystring params, ignore the rest
                function parsenHParams() {
                        var frags, keyval, i;
                        if (state.flags.gotParams) {
                                logInit();
                                chatlog("[0.1] -- begin parsenHParams(), already ran once, exiting.");
                                return;
                        }

                        frags = location.search.substr(1).split("&");
                        for (i = 0; i < frags.length; i += 1) {
                                keyval = frags[i].split("=");

                                if (activeParams[keyval[0]]) {
                                        activeParams[keyval[0]](keyval[1]);
                                        if (keyval[0] === "nHverbose") {
                                                logInit();
                                                chatlog("[0.0] begin init()", selector);
                                                chatlog("[0.0] -- calling parsenHParams()");
                                                chatlog("[0.1] -- begin parsenHParams()...");
                                        }
                                }
                                chatlog("[0.1]    -- parsed chunk #" + i + " ('" + frags[i] + "')");
                        }

                        state.flags.gotParams = true;   // make the method a one-timer
                        chatlog("[0.1] -- end parsenHParams()...");
                } // end parsenHParams()
                
                // AS: KEEP startTimer for logging timing to load external files like buttonMapper - if keeping logging
                function startTimer(key) {
                        if (!state.timestamp.hasOwnProperty(key)) {
                                state.timestamp[key] = {};
                        }
                        state.timestamp[key].start = new Date();
                }

                // AS: KEEP stopTimer - if keeping logging
                function stopTimer(key) {
                        state.timestamp[key].stop = new Date();
                }

                // AS: keep reportInterval for logging - if keeping logging
                function reportInterval(key, prefix, indent) {
                        var start = state.timestamp[key].start,
                                stop = state.timestamp[key].stop,
                                i;

                        state.timestamp[key].total = (stop - start);

                        if (prefix) {
                                prefix = '[' + prefix + '] ';
                        }
                        else {
                                prefix = '';
                        }

                        if (indent) {
                                for (i = 0; i < indent; i += 1) {
                                        prefix += '   ';
                                }
                        }

                        //chatlog("   -- start time: " + start.toISOString());
                        //chatlog("   -- stop time:  " + stop.toISOString());

                        chatlog(prefix + "-- " + key + " start time: " + start.toString() + " and " + start.getMilliseconds() + " milliseconds");
                        chatlog(prefix + "-- " + key + " stop time:  " + stop.toString() + " and " + stop.getMilliseconds() + " milliseconds");
                        chatlog(prefix + "-- " + key + " total time: " + state.timestamp[key].total + " millisec");
                }

                //AS: finish called when execution of promise is complete to stop time & write to the log if verbose enabled
                function finish() {
                        stopTimer("all");
                        if (state.flags.verbose) {
                                chatlog("-------------");
                                chatlog("-- begin finish(); total execution timing info:");
                                reportInterval("all", "", 1);
                                chatlog("-- end finish()");
                                chatlog("----> exiting current execution chain, need to check queue");
                        }
                } // end finish()

                // AS: Keep - loads the ButtonMapper file- left pretty much as-is
                function loadButtonMap(ignore) {
                        return new Promise(function (resolve, reject) {
                                chatlog("-------------");
                                chatlog("[2.0] begin loadButtonMap()");
                                if (state.flags.mapperJsonLoaded) {
                                        chatlog("[2.0] -- button mapper JSON is already loaded, done");
                                        chatlog("[2.0] end loadButtonMap()");
                                        resolve(state);
                                        return;
                                }

                                startTimer("json");
                                chatlog("[2.0] -- calling ajax() to get buttonMapper.json from " + state.buttonMapUrl);
                                getJson({
                                        url: state.buttonMapUrl,
                                        success: function (buttonMap) {  // statusStr, xhr
                                                var locale;
                                                stopTimer("json");

                                                chatlog("[2.1] -- begin callback for loadButtonMap()'s getJson()");
                                                reportInterval("json", "2.1", 1);

                                                if (!buttonMap || typeof buttonMap !== 'object') {
                                                        chatlog("[2.1]    -- ERROR, buttonMap is not defined or is empty!");
                                                        chatlog(buttonMap);
                                                        chatlog("[2.1] -- end callback for loadButtonMap()'s getJson()");
                                                        reject("ERROR, buttonMap is not defined or is empty!");
                                                        // AS: TO DO: see what happens if buttonmapper file is not found
                                                        // AS: Change behavior to setup default buttonid if buttonmapper not found (in state object?)
                                                }

                                                if (!buttonMap.CONFIG || typeof buttonMap.CONFIG !== 'object') {
                                                        chatlog("[2.1]    -- ERROR, buttonMap CONFIG is not defined or is empty!");
                                                        chatlog(buttonMap);
                                                        chatlog("[2.1] -- end callback for loadButtonMap()'s getJson()");
                                                        reject("ERROR, buttonMap CONFIG is not defined or is empty!");
                                                }

                                                state.envConfig = buttonMap.CONFIG;
                                                chatlog("[2.1]    -- LiveAgent config settings from JSON:", state.envConfig);
                                                chatlog(state.envConfig);
                                                state.flags.mapperJsonLoaded = true;

                                                chatlog("[2.1]    -- getting button info from buttonMapper");
                                                if (buttonMap[state.locale.chosen]) {
                                                        chatlog("[2.1]    -- found an entry for calculated locale [" + state.locale.chosen + "]");
                                                        locale = state.locale.chosen;
                                                }
                                                else if (state.locale.page && buttonMap[state.locale.page]) {
                                                        chatlog("[2.1]    -- no entry for calculated locale [" + state.locale.chosen + "]");
                                                        chatlog("[2.1]    ----> using page locale [" + state.locale.page + "]...");
                                                        locale = state.locale.page;
                                                }
                                                else {
                                                        // UC7: default to en_US
                                                        chatlog("[2.1]    -- ALERT: UC7 -- no button settings for calculated OR page locale");
                                                        chatlog("[2.1]    ----> using 'en_US' instead");
                                                        locale = 'en_US';
                                                }

                                                // pull current buttonids from map here and pass those to wireButtons()...
                                                state.buttonInfo = {
                                                        'buttonId': buttonMap[locale]["button-id"],
                                                        'proactiveId': buttonMap[locale]["proactive-id"],
                                                        'ecid': buttonMap[locale].ECID,
                                                        'dtid': buttonMap[locale].DTID,
                                                        'ccid': buttonMap[locale].CCID,
                                                        'oid': buttonMap[locale].OID,
                                                        'eid': ""
                                                };

                                                chatlog("[2.1]    -- buttonId    = [" + state.buttonInfo.buttonId + "]");
                                                chatlog("[2.1]    -- proactiveId = [" + state.buttonInfo.proactiveId + "]");
                                                chatlog("[2.1]    -- ecid = [" + state.buttonInfo.ecid + "]");
                                                chatlog("[2.1]    -- dtid = [" + state.buttonInfo.dtid + "]");
                                                chatlog("[2.1]    -- ccid = [" + state.buttonInfo.ccid + "]");
                                                chatlog("[2.1]    -- oid  = [" + state.buttonInfo.oid + "]");
                                                chatlog("[2.1] -- end callback for loadButtonMap()'s ajax()");

                                                resolve(state);
                                        },

                                        error: function (ignore, statusStr, error) {   // xhr
                                                chatlog("[2.1] ***ALERT***");
                                                chatlog("[2.1] ***ALERT*** -- getJson() of buttonMapper FAILED - possible syntax error in " + state.buttonMapUrl + " ??");
                                                chatlog("[2.1] ***ALERT*** --> statusStr: " + statusStr);
                                                chatlog("[2.1] ***ALERT*** --> error: " + error);
                                                chatlog("[2.1] ***ALERT*** --> Try checking the JSON by pasting it into http://jsonlint.com/");
                                                chatlog("[2.1] ***ALERT***");
                                                reject(error);
                                        }
                                });

                                chatlog("[2.0] ----> finished calling ajax(); look for its callback [2.1] to fire...");
                                chatlog("[2.0] end loadButtonMap()");
                        }); // end Promise
                }   // end 'loadButtonMap()'

                // AS: Commenting for now - can add later if support needed
                // function clearUidCache (key) {
                //        var uid = null;
                //        if (key && JSON) { // crazy MSIE...
                //                uid = JSON.parse(localStorage.getItem('userInfoDispatcher'));
                // be careful, uid (or uid.profile) might still be null
                //                if (uid && uid.profile) {
                //                        uid.profile[key] = null;
                //                        localStorage.setItem('userInfoDispatcher',JSON.stringify(uid));
                //                }
                //        }
                //        else {
                //                localStorage.removeItem('userInfoDispatcher');
                //        }
                //}

                // AS: Keep getMetaValue
                function getMetaValue(name) {
                        var metaNode = document.querySelector('meta[name=' + name + ']');
                        if (!metaNode) { return "unknown"; }
                        return metaNode.getAttribute('content') || "unknown";
                }

                // AS: Don't need initially but may be useful long term (ex giving employee or partner specific ruleid)
                function determineAccessLevel(ignore) {
                        return new Promise(function (resolve, reject) {
                                chatlog("-------------");
                                chatlog("[1.0] begin determineAccessLevel()");

                                if (state.flags.accessLevelDetermined) {
                                        chatlog("[1.0] this has already run, entitlement is " + state.entitlement + "; returning...");
                                        resolve(state); // success, can proceed in Promise chain to loadButtonMap
                                        chatlog("[1.0] end determineAccessLevel()");
                                        return;
                                }

                                chatlog("[1.0] -- calling userInfoDispatcher.getUserProfile(contactInfo)");
                                chatlog("[1.0] -- look for its callback [1.1] to fire...");
                                cdc.userInfoDispatcher.getUserProfile({
                                        "listOfDataFields": ["contactInfo"], // used to also get 'cps' and 'vps' but do not use them
                                        "callback": function (uid) {
                                                chatlog("[1.1] -- begin callback for userInfoDispatcher.getUserProfile()");
                                                chatlog("[1.1]    -- profile object:", uid);
                                                chatlog(uid);

                                                if (uid.contactInfo && typeof uid.contactInfo === "object") {
                                                        if (uid.contactInfo.accesslevel === "4") {
                                                                state.entitlement = "employee";
                                                        }
                                                        else {
                                                                // TODO: figure out what the other numeric codes map to (ex: partner)
                                                                state.entitlement = uid.contactInfo.accesslevel;
                                                        }
                                                }
                                                else {
                                                        chatlog("[1.1]    -- ALERT! uid.contactInfo is undefined or not an object!");
                                                }

                                                // debug setting to allow entitlement override
                                                if (state.override.entitlement) {
                                                        chatlog("[1.1]    -- user entitlement '" + state.entitlement + "' has been overidden to '" + state.override.entitlement + "'");
                                                        state.entitlement = state.override.entitlement;
                                                }

                                                chatlog("[1.1]    -- user entitlement is '" + state.entitlement + "'");

                                                // UC1: exit condition -- entitlement=employee
                                                /* AS: This doesn't apply for now -- commented out for now
                                                   may add handling in a later phase (ex. send partners & employees to specific ruleid)
                                                */

                                                /* 
                                                                                                if (state.entitlement) {
                                                        if (state.entitlement === "employee" || state.entitlement === 4 || state.entitlement === "4") {
                                                                chatlog("[1.1]    -- user is employee");
                                                                chatlog("[1.1]    -- [to override, use 'entitlementOverride=1' in the querystring]");
                                                                                                                                reject("-- user is employee, exiting (Use Case 1)");
                                                                return;
                                                        }
                                                }
                                                                                                */
                                                chatlog("[1.1] -- end callback for userInfoDispatcher.getUserProfile()");

                                                // AS: check for values like name, email, etc that we can pass to VA
                                                if (uid.contactInfo && typeof uid.contactInfo === "object") {
                                                        if (uid.contactInfo.accesslevel === "4") {
                                                                state.entitlement = "employee";
                                                        }
                                                        else {
                                                                // TODO: figure out what the other numeric codes map to...
                                                                state.entitlement = uid.contactInfo.accesslevel;
                                                        }
                                                }
                                                else {
                                                        chatlog("[1.1]    -- ALERT! uid.contactInfo is undefined or not an object!");
                                                }

                                                state.flags.accessLevelDetermined = true;
                                                resolve(state); // success, can proceed in Promise chain to loadButtonMap
                                        }
                                }); // end cdc.userInfoDispatcher.getUserProfile()

                                chatlog("[1.0] end determineAccessLevel()");
                        }); // end Promise
                } // end determineAccessLevel()

                // figure out the user's locale country and language codes, to derive buttonMapper key
                // AS: Left pretty much as-is
                function determineLocale(ignore) { // (chat)
                        return new Promise(function (resolve, reject) {
                                chatlog("-------------");
                                chatlog("[1.0] begin determineLocale()");

                                if (state.flags.localeDetermined) {
                                        chatlog("[1.0] this has already run, final locale is: '" + state.locale.chosen + "'; returning...");
                                        resolve(state); // success, can proceed in Promise chain to loadButtonMap
                                        chatlog("[1.0] end determineLocale()");
                                        return;
                                }

                                // grab page locale info from page's meta tags
                                //  <meta name="language" content="en"  />
                                //  <meta name="country" content="US"  />
                                state.locale.country.page = getMetaValue('country');
                                state.locale.lang.page = getMetaValue('language');
                                state.locale.page = state.locale.lang.page + '_' + state.locale.country.page;
                                chatlog("[1.0] -- page locale=[" + state.locale.page + "]");

                                // in test environments and sandboxes, uid fails because the login state is unobtainable
                                state.currAuthStatus = cdc.nHc.authStatus;
                                cdc.nHc.authStatus = "valid"; // the other useful value is "anonymous"
                                chatlog("[1.0] -- curr authStatus is: " + state.currAuthStatus);

                                // weird edge case for testers switching locales, but uid caches locale info...
                                // AS: Commenting for now - can add later if support needed
                                // if (state.flags.clearCache) {
                                //        chatlog("[1.0] -- UID cache before clearing:");
                                //        chatlog(JSON.parse(localStorage.getItem('userInfoDispatcher')));
                                //        chatlog("[1.0] -- clearing userInfoDispatcher localStorage cache before calling userInfoDispatcher.getUserProfile()");
                                //        clearUidCache();
                                //}

                                chatlog("[1.0] -- calling userInfoDispatcher.getUserProfile(locale)");
                                chatlog("[1.0] -- look for its callback [1.1] to fire...");
                                cdc.userInfoDispatcher.getUserProfile({
                                        "listOfDataFields": ["locale", "dsc"], // used to also get 'cps' and 'vps' but do not use them
                                        "callback": function (uid) {
                                                cdc.nHc.authStatus = state.currAuthStatus;
                                                chatlog("[1.1] -- begin callback for userInfoDispatcher.getUserProfile()");
                                                chatlog("[1.0]    -- curr authStatus is: " + cdc.nHc.authStatus);
                                                chatlog("[1.1]    -- profile object:", uid);
                                                chatlog(uid);

                                                chatlog("DSC: " + uid.dsc.netid.country_code);
                                                chatlog("Locale: " + uid.locale.country_code);
                                                if (uid.locale && typeof uid.locale === "object" && Object.keys(uid.locale).length > 0) {
                                                        state.locale.lang.visitor = uid.locale.language_code || "";
                                                        state.locale.country.visitor = uid.locale.country_code || "";

                                                        if (uid.locale.lang_unknown) {
                                                                chatlog("[1.1]       -- UID could not find a lang for '" + state.locale.country.visitor + "'");
                                                                chatlog("[1.1]       -- UID defaulted to using '" + state.locale.lang.visitor + "'");
                                                        }

                                                }
                                                else if (uid.dsc && typeof uid.dsc === "object" && Object.keys(uid.dsc).length > 0
                                                        && uid.dsc.netid && typeof uid.dsc.netid === "object" && Object.keys(uid.dsc.netid).length > 0) {
                                                        state.locale.country.visitor = uid.dsc.netid.country_code || "";

                                                        chatlog("[1.1]    -- ALERT! uid.dsc is defined");
                                                } else {
                                                        chatlog("[1.1]    -- ALERT! uid.locale/uid.dsc are not defined or not objects!");
                                                }

                                                chatlog("[1.1]    -- user's language=[" + state.locale.lang.visitor + "]");
                                                chatlog("[1.1]    -- user's country=[" + state.locale.country.visitor + "]");

                                                if (state.locale.lang.visitor && state.locale.country.visitor) {
                                                        state.locale.visitor = state.locale.lang.visitor + "_" + state.locale.country.visitor;
                                                        chatlog("[1.1]    -- user's locale=[" + state.locale.visitor + "]");
                                                        chatlog("[1.1]    ----> UC4 and UC8: use visitor's locale for button lookup");
                                                        state.locale.chosen = state.locale.visitor;
                                                }
                                                else {
                                                        state.locale.visitor = "";
                                                        chatlog("[1.1]    -- cannot determine user's locale!");
                                                        chatlog("[1.1]    ----> UC3 and UC9: use page locale for button lookup");
                                                        state.locale.chosen = state.locale.page;
                                                }

                                                if (state.override.locale) {
                                                        chatlog("[1.1]    -- locale override has been triggered [" + state.override.locale + "]");
                                                        state.locale.chosen = state.override.locale;
                                                }

                                                chatlog("[1.1]    -- final locale is: '" + state.locale.chosen + "'");
                                                chatlog("[1.1] -- end callback for userInfoDispatcher.getUserProfile()");

                                                state.flags.localeDetermined = true;
                                                resolve(state); // success, can proceed in Promise chain to determineAccessLevel
                                        }
                                }); // end cdc.userInfoDispatcher.getUserProfile()

                                chatlog("[1.0] end determineLocale()");
                        }); // end Promise
                } // end determineLocale()

                function resolveId(chatNode, id, type) {
                        var dataSelector = "data-c2c-buttonid",
                                newId;

                        if (type === "proactive") {
                                dataSelector = "data-c2c-proactive-buttonid";
                        }

                        newId = chatNode.getAttribute(dataSelector);
                        // AS: case if button id is hard coded on the page - keep for backward compatibility
                        if (newId) {
                                chatlog("[4.2]    --> UC5: found markup override " + type + "-id '" + newId + "', overriding old id '" + id + "'");
                                id = newId;
                        }
                        // AS: case if button id is passed in the URL - keep for backward compatibility
                        if (state.override[type + "Id"]) {
                                chatlog("[4.2]    --> found querystring override " + type + "-id '" + state.override[type + "Id"] + "', overriding old id '" + id + "'");
                                id = state.override[type + "Id"];
                        }

                        return id;
                } // end resolveId()


                function readOverrideValuesOMS(data, omsService) {


                        var ids = ["ccid", "oid", "ecid", "dtid", "eid"];
                        var overrideIds = {};

                        let data_oms = {}
                        if (omsService && data) {
                                for (let i = 0; i < data.length; ++i) {
                                        chatlog(data[i]);
                                        let all_keys = Object.keys(data[i]);
                                        for (let j = 0; j < all_keys.length; ++j) {
                                                data_oms[all_keys[j]] = data[i][all_keys[j]];
                                        }
                                }
                        }

                        chatlog("DATA OMS: " + data_oms);


                        for (var index = 0; index < ids.length; index++) {
                                var key = ids[index];
                                var value = getParameter(key);
                                chatlog("[0.1] INDEX: " + index);

                                if (value) {
                                        chatlog("IN URL");
                                        chatlog("[0.1] URL Key:" + key + " found with a value of " + value);
                                        chatlog("[0.1] INDEX: " + index);
                                        chatlog(key);
                                        overrideIds[key] = value;
                                }
                                else if (omsService && key in data_oms) {
                                        chatlog("OMS");
                                        chatlog("[0.1] OMS X-Key:" + key + " found with a value of " + data_oms[key]);
                                        chatlog(key);
                                        overrideIds[key] = data_oms[key];
                                }

                        }
                        for (var i = 0; i < localStorage.length; i++) {
                                chatlog("Key: " + localStorage.key(i));
                                chatlog("Value: " + localStorage.getItem(localStorage.key(i)));
                        }
                        window.threenHOverrideIds = overrideIds;
                }

                /* Read the querystring for a value override
                 * If there is a querystring value, set it into the cookie for 24 hours
                 *  If there is not querystring value, see if our cookie has any non-expired data
                                 *  AS: Gets the dtid, ecid, ccid, and oid
                 */
                function readOverrideValues() {
                        chatlog("[0.1] Reading Override Values from Querystring or Cookie");
                        if ((typeof ctmsRequire != "undefined") && (ctmsRequire.require.specified('ctmsUtil'))) {
                                ctmsRequire.require(["ctmsUtil"], function (util) {
                                        //Debug log
                                        if (util) {
                                                util.getOMS(["ccid", "oid", "ecid", "dtid", "eid"], function (data) {
                                                        readOverrideValuesOMS(data, true);
                                                        if (state.flags.initRunning) {
                                                                chatlog("[0.0] -- another init is already running, adding this one to initQ");
                                                                state.initQ.push(selector);
                                                        }
                                                        else {
                                                                chatlog("[0.0] -- this is the first init, calling execPromiseChain()");
                                                                state.flags.initRunning = true;
                                                                execPromiseChain(selector);
                                                        }
                                                        chatlog("[0.0] end init()", selector);
                                                });
                                        }
                                });
                        } else {
                                readOverrideValuesOMS();

                                if (state.flags.initRunning) {
                                        chatlog("[0.0] -- another init is already running, adding this one to initQ");
                                        state.initQ.push(selector);
                                }
                                else {
                                        chatlog("[0.0] -- this is the first init, calling execPromiseChain()");
                                        state.flags.initRunning = true;
                                        execPromiseChain(selector);
                                }
                                chatlog("[0.0] end init()", selector);

                        }
                }

                /*  1. it must scan the page for the existance of chat component
                 *
                 *
                 */

                function wireSingleButton(index, chatNode) {
                        var nodeNum = index;
                        return new Promise(function (resolve, ignore) { // , reject
                                chatlog("[4.2] ----");
                                chatlog("[4.2] -- begin wireSingleButton() for chat node #" + (nodeNum + 1) + ": ", chatNode);

                                // look for override button ids in chat nodes
                                // AS: don't need proactiveId, modalHeight or modalWidth, but left them in the wireParams object, just won't check them during setup (line 86)
                                var wireParams = {
                                        'buttonId': resolveId(chatNode, state.buttonInfo.buttonId, 'button'),
                                        'proactiveId': resolveId(chatNode, state.buttonInfo.proactiveId, 'proactive'),
                                        'modalHeight': chatNode.getAttribute("data-c2c-survey-height") || state.buttonInfo.modalHeight,
                                        'modalWidth': chatNode.getAttribute("data-c2c-survey-width") || state.buttonInfo.modalWidth,
                                        'ecid': state.buttonInfo.ecid,
                                        'dtid': state.buttonInfo.dtid,
                                        'ccid': state.buttonInfo.ccid,
                                        'oid': state.buttonInfo.oid,
                                        "eid": ""
                                },
                                        lastId;

                                chatlog("[4.2]    -- buttonId is: " + wireParams.buttonId);

                                var value = "";
                                // derive data-c2c-* attributes or querystring param overrides
                                var ids = ["dtid", "ecid", "ccid", "oid", "eid"];
                                for (var index = 0; index < ids.length; index++) {
                                        var key = ids[index];
                                        value = window.threenHOverrideIds[key] || chatNode.getAttribute("data-c2c-" + key) || wireParams[key];
                                        if (value) {
                                                wireParams["data-c2c-" + key] = value;
                                                chatlog("[4.2]    -- data-c2c-" + key + " is: " + wireParams["data-c2c-" + key]);
                                        }
                                }

                                if (!wireParams.buttonId.match(/,/)) {
                                        chatlog("[4.2]    -- id is not a list, proceeding.");
                                        resolve(
                                                function () {
                                                        state.noholdAdapter.setup({
                                                                'chatNode': chatNode,
                                                                'state': state,
                                                                'wireParams': wireParams
                                                        });
                                                }
                                        );
                                        return;
                                }

                                // AS: Do not support a list of button ids. If comma, separated list found, taking the last id
                                chatlog("[4.2]    -- id is a list, need to find first active id via REST API");
                                lastId = (wireParams.buttonId.split(',')).pop();
                                resolve(
                                        function () {
                                                wireParams.buttonId = lastId;
                                                state.noholdAdapter.setup({
                                                        'chatNode': chatNode,
                                                        'state': state,
                                                        'wireParams': wireParams
                                                });
                                        }
                                );
                                return;
                        }); // end new Promise
                } // end function wireSingleButton()

                // AS: Left pretty much as-is
                function wireButtons(ignore) { // chat
                        return new Promise(function (resolve, reject) {
                                var wirePromiseList = [],
                                        d;

                                chatlog("-------------");
                                chatlog("[4.0] begin wireButtons()");
                                chatlog("[4.0] -- buttonId=[" + state.buttonInfo.buttonId + "]");
                                chatlog("[4.0] -- number of chat nodes=[" + state.chatNodes.length + "]");

                                // process chatNodes as a collection of Promises
                                chatlog("[4.0] -- processing chat nodes into array of Promises that call wireSingleButton()...");

                                // create array of Promises to hand off to Promise.all() so Controller execution blocks on
                                // the completion of potentially asynch wiring
                                for (d = 0; d < state.chatNodes.length; d += 1) {
                                        //chatlog("[4.0]    -- chatNode #" + d + " = ", state.chatNodes[d]);
                                        wirePromiseList.push(wireSingleButton(d, state.chatNodes[d]));
                                }
                                chatlog("[4.0] -- done processing chat nodes; Promise array: =", wirePromiseList);

                                // all() takes an array of promises, and waits until they are done to yield an array of the resolved promises
                                chatlog("[4.0] -- passing Promise array to Promise.all()...");
                                Promise.all(wirePromiseList).then(
                                        function (agentCallbacks) {
                                                var ind;
                                                chatlog("[4.0] -- back from wireSingleButton() calls, results list: ", agentCallbacks);
                                                for (ind = 0; ind < agentCallbacks.length; ind += 1) {
                                                        chatlog("[4.0] -- calling Adapter.setup() for chat node #" + (ind + 1) + "...");
                                                        agentCallbacks[ind](); // this function was created in wireSingleButton(), which reolved its Promise by returning this function
                                                }
                                                finish();
                                                resolve(state);
                                        }
                                ).then(  // originally used Promise.catch(onRejected) here, but 'catch' is a keyword; then(undefined,onRejected) is equiv
                                        null,
                                        function (reason) {
                                                chatlog("[4.0] -- back from wireSingleButton() calls, something erred: " + reason);
                                                reject(reason);
                                        }
                                ); // end then()
                                chatlog("[4.0] end wireButtons()");
                        }); // end new Promise
                } // end function wireButtons

                // parse querystring and populate nHChat.debug and nHChat.flags.nHverbose
                //
                // Note: nHverbose will not be defined until parsenHParams() runs,
                //       so any calls to chatlog() before then will be no-ops

                function prepChain(selector) {
                        return new Promise(function (resolve, reject) {
                                chatlog("[0.3]    -- begin prepChain()");
                                if (!selector) {
                                        selector = 'body';
                                }

                                if (state.initCounter > 25) {
                                        chatlog("[ALERT] -- recursion alert!");
                                        reject('possible infinte recursion?');
                                }

                                state.initCounter += 1;
                                startTimer("all");

                                // get the chat nodes on this page, if any; NOTE: run on AJAXed content too
                                if (typeof selector === "string") {
                                        // AS: Take care of this id vs class later
                                        state.chatNodes = document.querySelectorAll(selector + " #nhbtn");
                                }
                                else {
                                        state.chatNodes = selector.querySelectorAll('#nhbtn');
                                }

                                // the first real exit condition is if there are no chat components on the page...
                                if (!state.chatNodes.length) {
                                        chatlog("[0.3]       ----> no chat components on page, exiting.");
                                        chatlog("[0.3]    -- end prepChain()");
                                        finish();
                                        reject("-- no chat components on page, exiting.");
                                        return;
                                }

                                chatlog("[0.3]       -- Found " + state.chatNodes.length + " chat components on page.");

                                //   -- NOTE: depends on JSON file being loaded first, for service URL
                                if (!state.noholdAdapter) {
                                        chatlog("[0.3]       -- creating Adapter instance for use downstream");
                                        state.noholdAdapter = new noHoldAdapter(chatlog, addEvent, getCookie);
                                }

                                // time to whack and wire!
                                // now call userInfoDispatcher to get entitlement and locale info about the user
                                chatlog("[0.3]       ----> no exit conditions found, proceeding with chat setup");
                                chatlog("[0.3]    -- end prepChain()");
                                resolve(state);
                        }); // end new Promise
                } // end 'prepChain()'

                function checkQueue() {
                        return new Promise(function (resolve, ignore) {
                                chatlog("-------------");
                                chatlog("[5.0] begin checkQueue()...");
                                if (state.initQ.length) {
                                        chatlog("[5.0] -- execution queue has an item, calling execPromiseChain()", state.initQ);
                                        //chatlog(state.initQ);
                                        chatlog("[5.0] end checkQueue()");
                                        execPromiseChain(state.initQ.shift());
                                }
                                else {
                                        chatlog("[5.0] -- execution queue is empty, done.");
                                        state.flags.initRunning = false;
                                        chatlog("[5.0] end checkQueue()");
                                        chatlog("----> EXIT CHAT CONTROLLER");
                                        chatlog("=============");
                                }
                                resolve(state);
                        }); // end Promise
                }

                // any reject()s in prepChain() will come here; they should checkQueue() for ajaxed stuff Q'ed up
                function logErrorMessage(error) {
                        chatlog('Interruption in chained Promises: ', error);
                        finish();
                        checkQueue();
                }

                // using chained Promises for asynch operations; see comment above about jslint and execPromiseChain...
                function execPromiseChain(selector) {
                        chatlog("[0.2] -- begin execPromiseChain(), calling prepChain()...");
                        prepChain(selector)
                                .then(determineLocale)
                                .then(determineAccessLevel)  // AS: In future, possibly use to send partners & employees to specific ruleid
                                .then(loadButtonMap)
                                .then(wireButtons)
                                .then(checkQueue, logErrorMessage);
                        chatlog("[0.2] -- end execPromiseChain()");
                } //; // for jslint add the semicolon after the brace. sheesh.

                /*
                 *     PUBLIC
                 *
                 */

                // grab any meaningful querystring params, ignore the rest
                parsenHParams();

                // expose for onready handler to use
                this.chatLog = chatlog;
                this.events = state.events;
                this.removeEvent = removeEvent;

                // if jasmine tests are being run, expose the state object
                //  AS: QUESTION FOR MICHAEL - still needed???
                // NOTE: this relies on parsenHParams() running first
                // if (state.flags.test) {
                //        this.state = state;
                // }

                readOverrideValues();
                // if a promise chain is already running, push selector onto state.initQ array;
                // final then() in execPromiseChain() should shift initQ and
                //    -->  if there is a selector, run another execPromiseChain()


        } // end defn of nHChat class

        // we are still in the chatController class here
        // - this is to expose the inner 'init()' and also the instance itself (for jasmine testing)
        var chatInstance = null;
        this.init = function (selector) {
                chatInstance = new nHChat(selector);
        };

        this.getChatInstance = function () {
                return chatInstance;
        };

}; // end cdc.nHc()

/* On ready:
 *
 * - create a Chat Controller instance
 * - bind a custom event handler 'loadnHC' to aid with ajaxed content
 * - call 'init()' on the body to wire up loaded chat buttons
 *
 */

// AS: Looks like this is where things kick off...
// replacement for jQuery(document).ready()... NOTE: does not support IE <= 8

cdc.nHc.initialize = function () {
        "use strict";
    if (document.getElementsByClassName('vabutton').length < 1) {

        var i, nHbtnNodes = document.querySelectorAll("#nhbtn");
        for (i = 0; i < nHbtnNodes.length; i += 1) {
                // AS: Keep for future use, if we support multiple buttons on the page
        }

        var nHChat = cdc.nHc,
                nHController = new nHChat();

        // fire an event
        function loadnHC(ignore, scopeSelector) { // triggerEvent
                scopeSelector = scopeSelector || 'body';
                nHController.init(scopeSelector); // interface to inner chat instance
        }

        // used for debugging in the console
        cdc.nHc.trigger = function (elem, eventName, dataObj) {
                var event;
                eventName = eventName || 'loadnHC';

                if (window.CustomEvent) {
                        event = new CustomEvent(eventName, { detail: dataObj });
                }
                else {
                        event = document.createEvent('CustomEvent');
                        event.initCustomEvent(eventName, true, true, dataObj);
                }

                elem.dispatchEvent(event);
        };

        // replacement for jQuery bind()
        try {
                if (typeof document.body.attachEvent !== 'undefined') {
                        document.body.attachEvent('onloadnHC', loadnHC);
                }
                else {
                        document.body.addEventListener('loadnHC', loadnHC);
                }
        } catch (evt) {
                chatlog("Warning: could not add onloadnHC event (" + evt.message + ")");
        }

        // finally, kick off the processing of the newly ready page
        nHController.init('body');
        
    }
}

const urlParams2 = new URLSearchParams(window.location.search);
var teliumOverride = urlParams2.get('teliumOverride');
if (teliumOverride == "1") {
        cdc.nHc.initialize();
        if(typeof cdc.c2c!=='undefined'){
                cdc.c2c.reinitialize(document);
        }
        chatlog("Telium Overide Enabled");
}


// AS: NOTE: ONLY RUNS FOR FIRST nhbtn ON THE PAGE.  WILL NEED TO DEBUG IF SUPPORT FOR MULTIPLE BUTTONS IS NEEDED